#include "game.hpp"
#include "engine.hpp"
#include "evaluation.hpp"
#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <algorithm>
#include <cmath>
#include <fstream>

using namespace std;

// Genome contains all tunable parameters
struct Genome {
    // Evaluation weights
    double materialWeight;
    double positionWeight;
    double kingSafetyWeight;
    double pawnStructureWeight;
    
    // Piece-square tables (simplified - 8x8 for each piece type)
    int pawnPST[8][8];
    int knightPST[8][8];
    int bishopPST[8][8];
    int rookPST[8][8];
    int queenPST[8][8];
    int kingPST[8][8];
    
    // Fitness tracking
    double fitness;
    int wins;
    int losses;
    int draws;
    int generation;
    
    Genome() : materialWeight(10), positionWeight(10), kingSafetyWeight(5), 
               pawnStructureWeight(0.1), fitness(0.0), wins(0), losses(0), 
               draws(0), generation(0) {
        // Initialize with zeros
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                pawnPST[i][j] = 0;
                knightPST[i][j] = 0;
                bishopPST[i][j] = 0;
                rookPST[i][j] = 0;
                queenPST[i][j] = 0;
                kingPST[i][j] = 0;
            }
        }
    }
    
    void saveToFile(const string& filename) const {
        ofstream file(filename);
        file << "// Auto-generated by genetic algorithm\n";
        file << "// Generation: " << generation << "\n";
        file << "// Fitness: " << fitness << "\n";
        file << "// Record: " << wins << "W-" << losses << "L-" << draws << "D\n\n";
        
        file << "Weights:\n";
        file << "materialWeight = " << materialWeight << "\n";
        file << "positionWeight = " << positionWeight << "\n";
        file << "kingSafetyWeight = " << kingSafetyWeight << "\n";
        file << "pawnStructureWeight = " << pawnStructureWeight << "\n\n";
        
        auto printPST = [&](const string& name, const int pst[8][8]) {
            file << "int " << name << "[8][8] = {\n";
            for (int i = 0; i < 8; i++) {
                file << "    {";
                for (int j = 0; j < 8; j++) {
                    file << (j == 0 ? "" : ",") << pst[i][j];
                    if (j < 7) file << (pst[i][j] < 10 && pst[i][j] >= 0 ? "  " : pst[i][j] < 100 && pst[i][j] >= 0 ? " " : "");
                }
                file << "}" << (i < 7 ? "," : "") << "\n";
            }
            file << "};\n\n";
        };
        
        printPST("pawnPST", pawnPST);
        printPST("knightPST", knightPST);
        printPST("bishopPST", bishopPST);
        printPST("rookPST", rookPST);
        printPST("queenPST", queenPST);
        printPST("kingPST", kingPST);
        
        file.close();
    }
};

// Custom evaluation class using genome
class GenomeEvaluation : public Evaluation {
private:
    const Genome& genome;

public:
    GenomeEvaluation(const Genome& g) : genome(g) {}

    double evaluate(const ChessGame& game) const {
        double evaluation = 0.0;
        evaluation += genome.materialWeight * materialCount(game);
        evaluation += genome.positionWeight * evaluatePosition(game);
        evaluation += genome.kingSafetyWeight * kingsafety(game);
        evaluation += genome.pawnStructureWeight * pawnStructure(game);
        return evaluation;
    }
    
private:
    double evaluatePosition(const ChessGame& game) const {
        double positionValue = 0.0;
        string fen = game.getCurrentFEN();
        size_t spacePos = fen.find(' ');
        string piecePlacement = fen.substr(0, spacePos);

        int row = 0, col = 0;

        for(char c : piecePlacement) {
            if(c == '/') {
                row++;
                col = 0;
                continue;
            }
            else if(isdigit(c)) {
                col += (c - '0');
                continue;
            }
            
            double pieceValue = 0;
            char piece = tolower(c);
            bool isWhite = isupper(c);
            int pstRow = isWhite ? row : (7 - row);
            
            switch(piece) {
                case 'p': pieceValue = genome.pawnPST[pstRow][col] / 100.0; break;
                case 'n': pieceValue = genome.knightPST[pstRow][col] / 100.0; break;
                case 'b': pieceValue = genome.bishopPST[pstRow][col] / 100.0; break;
                case 'r': pieceValue = genome.rookPST[pstRow][col] / 100.0; break;
                case 'q': pieceValue = genome.queenPST[pstRow][col] / 100.0; break;
                case 'k': pieceValue = genome.kingPST[pstRow][col] / 100.0; break;
                default: 
                    col++;
                    continue;
            }
            
            if(isWhite) {
                positionValue += pieceValue;
            } else {
                positionValue -= pieceValue;
            }
            
            col++;
        }

        return positionValue;
    }
};

// Play one game
string playGame(Genome& g1, Genome& g2, bool g1PlaysWhite, int depth) {
    ChessGame game;
    
    GenomeEvaluation eval1(g1);
    GenomeEvaluation eval2(g2);
    
    Engine engine1(eval1);
    Engine engine2(eval2);
    
    int moveCount = 0;
    int maxMoves = 120;
    
    while (!game.isGameOver() && moveCount < maxMoves) {
        bool isWhiteTurn = game.isWhiteToMove();
        
        Engine* currentEngine = nullptr;
        if ((isWhiteTurn && g1PlaysWhite) || (!isWhiteTurn && !g1PlaysWhite)) {
            currentEngine = &engine1;
        } else {
            currentEngine = &engine2;
        }
        
        Move bestMove = currentEngine->getBestMove(game, depth);
        
        if (bestMove.startRow == -1) {
            break;
        }
        
        game.makeEngineMove(bestMove);
        moveCount++;
    }
    
    if (game.isGameOver()) {
        string result = game.getGameResult();
        if (result.find("White wins") != string::npos) {
            return g1PlaysWhite ? "g1" : "g2";
        } else if (result.find("Black wins") != string::npos) {
            return g1PlaysWhite ? "g2" : "g1";
        }
    }
    
    return "draw";
}

// Evaluate fitness
void evaluateFitness(vector<Genome>& population, int gamesPerMatchup, int depth) {
    for (auto& g : population) {
        g.wins = 0;
        g.losses = 0;
        g.draws = 0;
        g.fitness = 0.0;
    }
    
    // Round-robin
    for (size_t i = 0; i < population.size(); i++) {
        for (size_t j = i + 1; j < population.size(); j++) {
            for (int game = 0; game < gamesPerMatchup; game++) {
                // Play both colors
                string result1 = playGame(population[i], population[j], true, depth);
                if (result1 == "g1") {
                    population[i].wins++;
                    population[j].losses++;
                } else if (result1 == "g2") {
                    population[j].wins++;
                    population[i].losses++;
                } else {
                    population[i].draws++;
                    population[j].draws++;
                }
                
                string result2 = playGame(population[i], population[j], false, depth);
                if (result2 == "g1") {
                    population[i].wins++;
                    population[j].losses++;
                } else if (result2 == "g2") {
                    population[j].wins++;
                    population[i].losses++;
                } else {
                    population[i].draws++;
                    population[j].draws++;
                }
            }
        }
    }
    
    for (auto& g : population) {
        int totalGames = g.wins + g.losses + g.draws;
        if (totalGames > 0) {
            g.fitness = (g.wins + 0.5 * g.draws) / totalGames;
        }
    }
}

// Initialize PST with reasonable values
void initializePST(Genome& g, mt19937& gen) {
    normal_distribution<> noise(0, 5);
    
    // Pawns: value advancing, especially center
    int pawnBase[8][8] = {
        {  0,  0,  0,  0,  0,  0,  0,  0},
        { 50, 50, 50, 50, 50, 50, 50, 50},
        { 10, 10, 20, 30, 30, 20, 10, 10},
        {  5,  5, 10, 25, 25, 10,  5,  5},
        {  0,  0,  0, 20, 20,  0,  0,  0},
        {  5, -5,-10,  0,  0,-10, -5,  5},
        {  5, 10, 10,-20,-20, 10, 10,  5},
        {  0,  0,  0,  0,  0,  0,  0,  0}
    };
    
    // Knights: center is better
    int knightBase[8][8] = {
        {-50,-40,-30,-30,-30,-30,-40,-50},
        {-40,-20,  0,  0,  0,  0,-20,-40},
        {-30,  0, 10, 15, 15, 10,  0,-30},
        {-30,  5, 15, 20, 20, 15,  5,-30},
        {-30,  0, 15, 20, 20, 15,  0,-30},
        {-30,  5, 10, 15, 15, 10,  5,-30},
        {-40,-20,  0,  5,  5,  0,-20,-40},
        {-50,-40,-30,-30,-30,-30,-40,-50}
    };
    
    // Apply base + noise
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            g.pawnPST[i][j] = pawnBase[i][j] + (int)noise(gen);
            g.knightPST[i][j] = knightBase[i][j] + (int)noise(gen);
            g.bishopPST[i][j] = -20 + (i + j) * 3 + (int)noise(gen);  // Diagonals
            g.rookPST[i][j] = (i == 1 ? 10 : 0) + (int)noise(gen);    // 7th rank
            g.queenPST[i][j] = (i >= 2 ? 5 : -10) + (int)noise(gen);  // Develop later
            g.kingPST[i][j] = (i == 7 && (j <= 2 || j >= 5) ? 20 : -30) + (int)noise(gen); // Castle
        }
    }
}

// Crossover
Genome crossover(const Genome& p1, const Genome& p2, mt19937& gen) {
    uniform_real_distribution<> prob(0.0, 1.0);
    Genome child;
    
    // Blend weights
    double alpha = prob(gen);
    child.materialWeight = alpha * p1.materialWeight + (1 - alpha) * p2.materialWeight;
    child.positionWeight = alpha * p1.positionWeight + (1 - alpha) * p2.positionWeight;
    child.kingSafetyWeight = alpha * p1.kingSafetyWeight + (1 - alpha) * p2.kingSafetyWeight;
    child.pawnStructureWeight = alpha * p1.pawnStructureWeight + (1 - alpha) * p2.pawnStructureWeight;
    
    // Crossover PST (take each square from random parent)
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            child.pawnPST[i][j] = (prob(gen) < 0.5) ? p1.pawnPST[i][j] : p2.pawnPST[i][j];
            child.knightPST[i][j] = (prob(gen) < 0.5) ? p1.knightPST[i][j] : p2.knightPST[i][j];
            child.bishopPST[i][j] = (prob(gen) < 0.5) ? p1.bishopPST[i][j] : p2.bishopPST[i][j];
            child.rookPST[i][j] = (prob(gen) < 0.5) ? p1.rookPST[i][j] : p2.rookPST[i][j];
            child.queenPST[i][j] = (prob(gen) < 0.5) ? p1.queenPST[i][j] : p2.queenPST[i][j];
            child.kingPST[i][j] = (prob(gen) < 0.5) ? p1.kingPST[i][j] : p2.kingPST[i][j];
        }
    }
    
    return child;
}

// Mutation
void mutate(Genome& g, double mutationRate, mt19937& gen) {
    uniform_real_distribution<> prob(0.0, 1.0);
    normal_distribution<> weightAdj(0.0, 0.5);
    normal_distribution<> pstAdj(0.0, 5.0);
    
    // Mutate weights
    if (prob(gen) < mutationRate) g.materialWeight = max(1.0, g.materialWeight + weightAdj(gen));
    if (prob(gen) < mutationRate) g.positionWeight = max(0.1, g.positionWeight + weightAdj(gen));
    if (prob(gen) < mutationRate) g.kingSafetyWeight = max(0.1, g.kingSafetyWeight + weightAdj(gen));
    if (prob(gen) < mutationRate) g.pawnStructureWeight = max(0.01, g.pawnStructureWeight + weightAdj(gen));
    
    // Mutate PST (only mutate a few squares per mutation)
    int numMutations = 3 + (int)(prob(gen) * 5);  // 3-7 squares
    for (int m = 0; m < numMutations; m++) {
        int i = (int)(prob(gen) * 8);
        int j = (int)(prob(gen) * 8);
        
        if (prob(gen) < 0.2) g.pawnPST[i][j] += (int)pstAdj(gen);
        if (prob(gen) < 0.2) g.knightPST[i][j] += (int)pstAdj(gen);
        if (prob(gen) < 0.2) g.bishopPST[i][j] += (int)pstAdj(gen);
        if (prob(gen) < 0.2) g.rookPST[i][j] += (int)pstAdj(gen);
        if (prob(gen) < 0.2) g.queenPST[i][j] += (int)pstAdj(gen);
        if (prob(gen) < 0.2) g.kingPST[i][j] += (int)pstAdj(gen);
    }
}

int main() {
    cout << "Advanced Genetic Algorithm - PST Evolution\n";
    cout << "===========================================\n\n";
    
    int populationSize = 20;
    int generations = 30;
    int gamesPerMatchup = 5;
    int depth = 5;
    double mutationRate = 0.4;
    
    cout << "This will evolve piece-square tables and weights.\n";
    cout << "Population: " << populationSize << ", Generations: " << generations << "\n";
    cout << "Games per matchup: " << gamesPerMatchup << " (x2 colors), Depth: " << depth << "\n";
    cout << "Mutation rate: " << mutationRate << "\n\n";
    
    int gamesPerGen = (populationSize * (populationSize - 1) / 2) * gamesPerMatchup * 2;
    int totalGames = gamesPerGen * generations;
    cout << "Total games: " << totalGames << " (~" << (int)(totalGames * 0.03 / 60) << " minutes)\n\n";
    
    cout << "Press Enter to start...";
    cin.get();
    
    random_device rd;
    mt19937 gen(rd());
    
    vector<Genome> population(populationSize);
    
    // Initialize population
    for (auto& g : population) {
        initializePST(g, gen);
    }
    
    Genome best;
    
    for (int genNum = 0; genNum < generations; genNum++) {
        cout << "\n========== Generation " << (genNum + 1) << "/" << generations << " ==========\n";
        
        evaluateFitness(population, gamesPerMatchup, depth);
        
        sort(population.begin(), population.end(), 
             [](const Genome& a, const Genome& b) { return a.fitness > b.fitness; });
        
        cout << "Top 3:\n";
        for (int i = 0; i < min(3, (int)population.size()); i++) {
            cout << (i+1) << ". " << (int)(population[i].fitness*100) << "% (" 
                 << population[i].wins << "W-" << population[i].losses << "L-" 
                 << population[i].draws << "D)\n";
        }
        
        if (population[0].fitness > best.fitness) {
            best = population[0];
            best.generation = genNum + 1;
            best.saveToFile("best_genome_gen" + to_string(genNum + 1) + ".txt");
            cout << "*** New best saved! ***\n";
        }
        
        // Create next generation
        vector<Genome> newPop;
        newPop.push_back(population[0]);  // Elitism
        newPop.push_back(population[1]);
        
        while (newPop.size() < (size_t)populationSize) {
            // Tournament selection
            int i1 = gen() % population.size();
            int i2 = gen() % population.size();
            int i3 = gen() % population.size();
            int i4 = gen() % population.size();
            
            Genome& p1 = (population[i1].fitness > population[i2].fitness) ? population[i1] : population[i2];
            Genome& p2 = (population[i3].fitness > population[i4].fitness) ? population[i3] : population[i4];
            
            Genome child = crossover(p1, p2, gen);
            mutate(child, mutationRate, gen);
            newPop.push_back(child);
        }
        
        population = newPop;
    }
    
    cout << "\n\n========== EVOLUTION COMPLETE ==========\n";
    cout << "Best genome has fitness: " << (int)(best.fitness * 100) << "%\n";
    cout << "Saved to: best_genome_gen" << best.generation << ".txt\n";
    
    return 0;
}
